---
title: "2. laboratorijska vježba"
author: "Ivan Klabucar"
subtitle: "Multivarijatna analiza podataka"
date: "ak. god. 2021/2022"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library("reshape2")
library(GGally)
library(psych)
library(data.table)
library(dplyr)
library("lattice")
library(moments)
library(nortest)
library(energy)
library(plotly)
library(car)
library('MASS')
library(hrbrthemes)
library(yardstick)
```


## 1. Uvod i upute za predaju

Cilj ove laboratorijske vježbe je primijeniti osnovne koncepte multivarijatne analize podataka, istražiti podatke te ispitati hipoteze. Preduvjet za rješavanje vježbe je osnovno znanje programskog jezika _R_ i rad s _R Markdown_ dokumentima. Sama vježba je koncipirana kao projekt u kojem istražujete i eksperimentirate koristeći dane podatke - ne postoji nužno samo jedan točan način rješavanja svakog podzadatka.

Rješavanje vježbe svodi se na čitanje uputa u tekstu ovog dokumenta, nadopunjavanje blokova kôda (možete dodavati i dodatne blokove kôda ukoliko je potrebno) i ispisivanje rezultata (u vidu ispisa iz funkcija, tablica i grafova). Vježbu radite samostalno, a svoje rješenje branite na terminima koji su vam dodijeljeni u kalendaru. Pritom morate razumjeti teorijske osnove u okviru onoga što je obrađeno na predavanjima i morate pokazati da razumijete sav kôd koji ste napisali.

Vaše rješenje potrebno je predati u sustav _Moodle_ u obliku dvije datoteke: 

1. Ovaj .Rmd dokument s Vašim rješenjem (naziva IME_PREZIME_JMBAG.rmd),  
2. PDF ili HTML dokument kao izvještaj generiran iz vašeg .Rmd rješenja (također naziva IME_PREZIME_JMBAG).

Rok za predaju je **15. svibnja 2022. u 23:59h**. **Jedan od uvjeta za prolaz predmeta je minimalno ostvarenih 50% bodova na svim laboratorijskim vježbama. Nadoknade laboratorijskih vježbi neće biti organizirane.** Za sva dodatna pitanja svakako se javite na email adresu predmeta: _map@fer.hr_.


## 2. Podatkovni skup
U laboratorijskoj vježbi razmatra se dinamika cijena vrijednosnica na financijskim tržištima. Dane su povijesne tjedne cijene ETF-ova (eng. exchange traded fund) koji prate određene dioničke, obvezničke ili druge indekse. Konkretno, radi se o sljedećim fondovima:

- `AGG` (iShares Core U.S. Aggregate Bond ETF) - obveznice s američkog tržišta,
- `IEF` (iShares 7-10 Year Treasury Bond ETF) - srednjeročne državne obveznice,
- `LQD` (iShares iBoxx $ Investment Grade Corporate Bond ETF) - korporativne obveznice,
- `SHY` (iShares 1-3 Year Treasury Bond ETF) - kratkoročne državne obveznice,
- `TIP` (iShares TIPS Bond ETF) - državne obveznice zaštićene od inflacije,
- `TLT` (iShares 20+ Year Treasury Bond ETF) - dugoročne državne obveznice,
- `DBC` (Invesco DB Commodity Index Tracking Fund) - sirovine i roba,
- `GLD` (SPDR Gold Trust) - zlato,
- `USO` (United States Oil Fund) - nafta,
- `IJH` (iShares Core S&P Mid-Cap ETF) - dionice tvrtki s američkog tržišta,
- `IWM` (iShares Russell 2000 ETF) - dionice američkih tvrtki s malim kapitalom,
- `SPY` (SPDR S&P 500 ETF Trust) - dionice tvrtki s američkog tržišta,
- `VTV` (Vanguard Value ETF) - dionice tvrtki s američkog tržišta,
- `XLB` (Materials Select Sector SPDR Fund) - dionice tvrtki za materijale,
- `XLE` (Energy Select Sector SPDR Fund) - dionice tvrtki energetskog sektora,
- `XLF` (Financial Select Sector SPDR Fund) - dionice tvrtki financijskog sektora,
- `XLI` (Industrial Select Sector SPDR Fund) - dionice tvrtki industrijskog sektora,
- `XLK` (Technology Select Sector SPDR Fund) - dionice tvrtki iz tehnološkog sektora,
- `XLP` (Consumer Staples Select Sector SPDR Fund) - dionice tvrki za necikličku potrošačku robu,
- `XLU` (Utilities Select Sector SPDR Fund) - dionice tvrtki komunalnih djelatnosti,
- `XLV` (Health Care Select Sector SPDR Fund) - dionice tvrtki iz zdravstvenog sektora,
- `XLY` (Consumer Discretionary Select Sector SPDR Fund) - dionice tvrtki za cikličku potrošačku robu,
- `IYR` (iShares U.S. Real Estate ETF) - dionice tvrtki iz područja nekretnina,
- `VNQ` (Vanguard Real Estate Index Fund) - dionice tvrtki iz područja nekretnina.

Pri modeliranju zajedničkog kretanja i rizika vrijednosnica, najčešće se koriste povrati: $R(t) = \frac{S(t)-S(t-1)}{S(t-1)},$ gdje je $S(t)$ cijena vrijednosnice u tjednu $t$. 

### 2.1. Učitavanje podataka i korelacijska analiza
Podaci se nalaze u datoteci "ETFprices.csv". Učitajte ih, provjerite ispravnost, izračunajte tjedne povrate te vizualizirajte matricu korelacije povrata - razmislite o grupama i korelacijskim strukturama koje u njoj vidite. U ostatku laboratorijske vježbe također koristite povrate, a ne cijene. 
```{r ucitavanje podataka}
ETF.prices = read.csv(file = 'ETFprices.csv')
ETF.prices$Time = as.Date(ETF.prices$Time, "%d-%b-%Y")

summary(ETF.prices)
head(ETF.prices)
```

```{r racunanje povrata}
n = nrow(ETF.prices)
p = ncol(ETF.prices)

ETF_returns = ((data.matrix(ETF.prices[2:n,2:p]) - data.matrix(ETF.prices[1:(n-1),2:p]))/data.matrix(ETF.prices[1:(n-1),2:p]))

ETF_returns = cbind(ETF.prices$Time[2:n],as.data.frame(ETF_returns))
names(ETF_returns)[1] <- "Time"
head(ETF_returns)
```
```{r korelacija}
R = cor(ETF_returns[,2:p])
ggcorr(ETF_returns,label = TRUE, label_size=3, cex=3)
```
## 3. Analiza glavnih komponenti
Cilj ovog zadatka je analizirati kretanje danih ETF-ova i izračunati glavne komponente koje objašnjavaju njihovu dinamiku.

### 3.1. Glavne komponente
Izračunajte glavne komponente matrice korelacije i izračunajte koliki udio varijance objašnjavaju. Odredite broj glavnih komponenti koje ćete zadržati u analizi. Grafički prikažite i usporedite koeficijente prvih nekoliko komponenti.
```{r svojstvene vrijednosti i vektori korelacije}

ev_R = eigen(R)

lambda_R = ev_R$values
e_R = ev_R$vectors

lambda_R

sum(lambda_R)
tr(R)
sum(lambda_R[1:3])/sum(lambda_R)
sum(lambda_R[1:4])/sum(lambda_R)
```

```{r scree plot}

#scree plot za glavne komponente kovarijance
plot(lambda_R, type = "b", cex.lab=0.75, cex.main=0.75, cex.axis=0.75, xlab="i", ylab=expression(lambda["i"]), main='Scree plot svojstvenih vrijednosti korelacijske matrice')
grid()

```
```{r vizualizacija svojstvenih vektora}
midpts <- barplot(e_R[,1], col="#69b3a2", main="1. svojstveni vektor korelacijske matrice") # assign result to named object
axis(1, at = midpts, labels=colnames(ETF_returns[,2:p]), cex.axis=0.47) # shrinks axis labels

midpts <- barplot(e_R[,2], col="#69b3a2", main="2. svojstveni vektor korelacijske matrice") # assign result to named object
axis(1, at = midpts, labels=colnames(ETF_returns[,2:p]), cex.axis=0.47) # shrinks axis labels

midpts <- barplot(e_R[,3], col="#69b3a2", main="3. svojstveni vektor korelacijske matrice") # assign result to named object
axis(1, at = midpts, labels=colnames(ETF_returns[,2:p]), cex.axis=0.47) # shrinks axis labels

midpts <- barplot(e_R[,4], col="#69b3a2", main="4. svojstveni vektor korelacijske matrice") # assign result to named object
axis(1, at = midpts, labels=colnames(ETF_returns[,2:p]), cex.axis=0.47) # shrinks axis labels

```

Prikažite graf raspršenja prve dvije glavne komponente i proučite možete li primijetiti neke grupe fondova. 
```{r} 

Y = R%*%e_R
plot(Y[,1],Y[,2], pch = 20, main="graf raspršenja fondova po prve dvije glavne komponente", cex=0.7, cex.lab=0.5, cex.axis=0.5, xlab=expression("Prva komponenta"), ylab=expression("Druga komponenta"), xlim=c(-1.8,3.9), ylim=c(-2,0.2))
grid()
#moguce je dodati i tekst - pritom treba pripaziti na citljivost
text(Y[,1]+0.06,Y[,2]-0.04, colnames(ETF_returns[,2:p]),cex=0.4)
```

### 3.2. Svojstveni portfelji

U primjeni PCA i svojstvenoj dekompoziciji kovarijance u financijama, svojstveni vektori se često zovu i tzv. svojstveni portfelji. Općenito, portfelj je vektor $w = [w_1,...,w_N]$ u kojem svaki element predstavlja težinu ili udio kapitala u određenoj vrijednosnici. Često je dobro pomnožiti njihove težine s predznakom njihove sume - na taj način zapravo samo "okrećemo" predznak svojstvenog vektora tako da mu je suma pozitivna (konačni PCA rastav je i dalje isti ako svojstveni vektor pomnožimo s -1). Također, dobro je i skalirati svojstvene portfelje sa sumom njihovih apsolutnih vrijednosti:
$\tilde{w}_i = \frac{w_i}{\sum_j^N{\vert w_j \vert}}$.
Na taj način se osigurava da visoke magnitude pojedinih elemenata ne uzrokuju velike razlike u volatilnostima svojstvenih portfelja.
Ukoliko znamo povrate $R\in\mathbb{R}^{T\times N}$ (gdje je $R_i\in\mathbb{R}^{T}$ vektor povrata za vrijednosnicu $i$) za $N$ vrijednosnica u nekom vremenskom periodu od $T$ dana, povrate portfelja $w$ u tom istom periodu možemo izračunati kao:
$R_p = \sum{R_i w_i} = R\cdot w$.
Izračunajte skalirane svojstvene portfelje $\tilde{w}$ koji proizlaze iz prve dvije glavne komponente. Za ta dva svojstvena portfelja izračunajte povijesne povrate kroz razmatrani period. Grafički prikažite vremensko kretanje njihovih vrijednosti tako da njihove povrate "vratite" natrag u cijene, s tim da početna cijena bude jednaka za oba portfelja, npr. $V_0 = 100$. Vrijednost portfelja u trenutku $t$ možemo izračunati po formuli: $V_t = V_{t-1}\cdot(1+R_{t})$.


```{r}
normalize <- function(x) {x / sqrt(sum(x^2))}
w1 = normalize(e_R[,1]*sign(sum(e_R[,1])))
w2 = normalize(e_R[,2]*sign(sum(e_R[,2])))

w1_returns = as.matrix(ETF_returns[,2:p]) %*% w1
w2_returns = as.matrix(ETF_returns[,2:p]) %*% w2
w1_price = Reduce(function(x,r) {x * (1+r)}, w1_returns, init=100, accumulate=T)
w2_price = Reduce(function(x,r) {x * (1+r)}, w2_returns, init=100, accumulate=T)


chron_prices = data.frame(date = ETF.prices$Time, w1_price = w1_price, w2_price = w2_price)
theme_set(theme_minimal())
ggplot(chron_prices, aes(x=date)) + 
  geom_line(aes(y = w1_price, color = "w1") ) + 
  geom_line(aes(y = w2_price, color="w2")) +
  scale_color_manual(name = "Colors", 
                     values = c("w1" = "brown4", "w2" = "darkolivegreen4")) + 
  scale_x_date(date_breaks = "1 year", date_labels ="%Y") +
  labs(title="Vrijednost prva dva svojstvena portfelja kroz vrijeme", y="Vrijednost ($)", x="time")

print("w1:")
print(w1)
print("w2:")
print(w2)
```

## 4. Faktorska analiza

### 4.1. Metode procjena koeficijenata modela
Na danim podacima odredite broj faktora te procijenite faktorski model pomoću metode glavnih komponenti i metode najveće izglednosti. Usporedite procjene ove dvije metode. Koja Vam se čini bolja? Što možete zaključiti iz vrijednosti faktora? Pronađite procjenu vrijednosti faktora koja daje najbolju interpretabilnost.

#### Metoda glavnih komponenti
```{r}
L = sqrt(lambda_R[1])*e_R[,1]
L = cbind(L,sqrt(lambda_R[2])*e_R[,2])
L = cbind(L,sqrt(lambda_R[3])*e_R[,3])

h = rowSums(L^2)
psi = 1-h
residual = R - L%*%t(L) - diag(psi)

df_factors <- as.data.frame(L)
rownames(df_factors) <- colnames(ETF_returns[,2:p])
colnames(df_factors) <- c('F1', 'F2', 'F3')

df_h <- as.data.frame(h)
rownames(df_h) <- colnames(ETF_returns[,2:p])
colnames(df_h) <- c('communality')

df_psi <- as.data.frame(psi)
rownames(df_psi) <- colnames(ETF_returns[,2:p])
colnames(df_psi) <- c('psi')

print(df_factors)
print(df_h)
print(df_psi)

ggplot(data = melt(residual), aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low="blue", high="coral")+
  #scale_fill_gradient(low="white", high="blue") +
  theme_ipsum() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title="Rezidual korelacijske matrice")

which(residual < -0.2, arr.ind = TRUE)
which(residual > 0.2, arr.ind = TRUE)
```

```{r}
 round(residual,digits = 3)
```

#### Metoda najveće izglednosti (MLE)
```{r}
fa = factanal(factors = 3, covmat = R,rotation="none")

fa$loadings
```

```{r}
rowSums(fa$loadings^2)
fa$uniqueness
```

```{r}
residual = R - fa$loadings%*%t(fa$loadings) - diag(fa$uniquenesses)

ggplot(data = melt(residual), aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low="blue", high="coral")+
  #scale_fill_gradient(low="white", high="blue") +
  theme_ipsum() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title="Rezidual korelacijske matrice")
```

```{r}
round(residual,digits = 3)
```

```{r mle - rotacija}

fa = factanal(factors = 3, covmat = R,rotation="varimax")

print(fa$loadings)

```

Za razliku od metode glavnih komponenti, u slučaju promjene broja faktora u metodi najveće izglednosti, promijenit će se i sve procjene koeficijenata faktorskog modela.

### 4.2. Specifične varijance faktora
Izračunajte specifične varijance faktora za model s dva faktora i model s tri faktora. Pomoću stupčastog dijagrama prikažite i usporedite dobivene vrijednosti. 
```{r}
fa2 = factanal(factors = 2, covmat = R,rotation="varimax", lower = 0.1)
fa3 = factanal(factors = 3, covmat = R,rotation="varimax")





barplot(rbind(fa2$uniqueness,fa3$uniqueness), beside=TRUE, col=c("cornflowerblue", "bisque"), main="Specifične varijance",ylab="Var", cex.axis = 0.75, cex.names = 0.45, cex.main=0.85, cex.lab=0.75)
legend("topright", 
       legend = c("2 Faktora","3 Faktora", "PCA"), 
       fill = c("cornflowerblue", "bisque"),
       cex = 0.65)

```
```{r}
print(fa2$loadings)
print(fa3$loadings)
```
## 5. Diskriminantna analiza
Financijska tržišta su od listopada 2007. do srpnja 2009. godine bila u krizi. U datoteci "crisis.csv" za svaki tjedan iz prethodno učitanih povijesnih tjednih cijena možete pronaći je li tržište tada bilo u krizi ili ne - 1 predstavlja krizu, 0 predstavlja period bez krize. Učitajte nove podatke te ih spojite s tablicom povrata.
```{r}
ETF.crisis = read.csv("crisis.csv")
ETF.crisis$Time = as.Date(ETF.crisis$Time, "%d.%m.%Y")
ETF.crisis <- ETF.crisis[-1,]

dim(ETF.crisis)
dim(ETF_returns)
head(ETF.crisis)

crisis <- ETF.crisis[,'Crisis']
returns <- cbind(ETF_returns, crisis)
head(returns)
```

### 5.1. Diskriminantna analiza pomoću povrata

Provedite diskriminantnu analizu koja tjedne odvaja na krizne i one bez krize pomoću povrata fondova. Pomoću stupčastog dijagrama prikažite vektore srednjih vrijednosti u krizi i izvan nje. Također, na isti način prikažite korelaciju fonda AGG (Aggregate Bond ETF-a) s ostalim fondovima u krizi i izvan krize. Usporedite rezultate linearne diskriminantne analize (funkcija u R-u: `lda`) i kvadratne diskriminantne analize (funkcija u R-u: `qda`) pomoću tablica konfuzije i mjere APER (eng. apparent error rate). Razmislite o tome koji je razlog razlike u rezultatima ove dvije metode.

```{r}
lda.fit <- lda(crisis ~ . - Time, data = returns)
lda.fit
```

```{r}
barplot(lda.fit$means, beside=TRUE, col=c("cornflowerblue", "coral"), main="Vektori srednjih vrijednosti dvaju populacija", cex.axis = 0.75, cex.names = 0.45, cex.main=0.85, cex.lab=0.75)
legend("bottomleft", 
       legend = c("bez krize","kriza"), 
       fill = c("cornflowerblue", "coral"),
       cex = 0.65)

no_crisis_returns <- subset(returns[returns$crisis == 0,], select=-c(Time, crisis))
crisis_returns    <- subset(returns[returns$crisis == 1,], select=-c(Time, crisis))

cor_by_crisis_data <- rbind(cor(no_crisis_returns)["AGG", ], cor(crisis_returns)["AGG", ])

barplot(cor_by_crisis_data, beside=TRUE, col=c("cornflowerblue", "coral"), main="Korelacije fonda AGG", cex.axis = 0.75, cex.names = 0.45, cex.main=0.85, cex.lab=0.75)
legend("bottomleft", 
       legend = c("bez krize","kriza"), 
       fill = c("cornflowerblue", "coral"),
       cex = 0.65)
```
#### Usporedba lda i qda
```{r}
lda.fit <- lda(crisis ~ . - Time, data = returns)
lda.fit

lda_conf <- t(table(predict(lda.fit,type="class")$class, returns$crisis))
names(dimnames(lda_conf)) <- c('TRUE', 'PREDICTED')
print("Confusion matrix")
print(lda_conf)
print("APER:")
print((sum(lda_conf)-tr(lda_conf))/sum(lda_conf))
```

```{r}
qda.fit <- qda(crisis ~ . - Time, data = returns)
qda.fit

qda_conf <- t(table(predict(qda.fit,type="class")$class, returns$crisis))
names(dimnames(qda_conf)) <- c('TRUE', 'PREDICTED')
print('Confusion Matrix:')
print(qda_conf)
print("APER:")
print((sum(qda_conf)-tr(qda_conf))/sum(qda_conf))
```

### 5.2. Diskriminantna analiza pomoću glavnih komponenti

Provedite diskriminantnu analizu kao u prošlom podzadatku, no ovaj put koristeći glavne komponente izračunate u 3. zadatku kao varijable. Provjerite i usporedite uspješnost klasifikacije koristeći tablice konfuzije i APER za različit broj komponenti. 

```{r} 
just_returns <- subset(returns, select=-c(Time, crisis))

compressed_ret_3 <- as.matrix(just_returns) %*% e_R[,1:3]
compressed_ret_3 <- data.frame(cbind(compressed_ret_3, returns$crisis))
names(compressed_ret_3)[ncol(compressed_ret_3)] <- c('crisis')

compressed_ret_6 <- as.matrix(just_returns) %*% e_R[,1:6]
compressed_ret_6 <- data.frame(cbind(compressed_ret_6, returns$crisis))
names(compressed_ret_6)[ncol(compressed_ret_6)] <- c('crisis')

compressed_ret_12 <- as.matrix(just_returns) %*% e_R[,1:12]
compressed_ret_12 <- data.frame(cbind(compressed_ret_12, returns$crisis))
names(compressed_ret_12)[ncol(compressed_ret_12)] <- c('crisis')

compressed_ret_24 <- as.matrix(just_returns) %*% e_R[,1:24]
compressed_ret_24 <- data.frame(cbind(compressed_ret_24, returns$crisis))
names(compressed_ret_24)[ncol(compressed_ret_24)] <- c('crisis')


head(compressed_ret_3)
```

```{r}
qda3.fit <- qda(crisis ~ ., data = compressed_ret_3)
qda3.fit

qda3_conf <- t(table(predict(qda3.fit,type="class")$class, returns$crisis))
names(dimnames(qda3_conf)) <- c('TRUE', 'PREDICTED')
print('Confusion Matrix:')
print(qda3_conf)
```

```{r}
qda6.fit <- qda(crisis ~ ., data = compressed_ret_6)
qda6.fit

qda6_conf <- t(table(predict(qda6.fit,type="class")$class, returns$crisis))
names(dimnames(qda6_conf)) <- c('TRUE', 'PREDICTED')
print('Confusion Matrix:')
print(qda6_conf)
```

```{r}
qda12.fit <- qda(crisis ~ ., data = compressed_ret_12)
qda12.fit

qda12_conf <- t(table(predict(qda12.fit,type="class")$class, returns$crisis))
names(dimnames(qda12_conf)) <- c('TRUE', 'PREDICTED')
print('Confusion Matrix:')
print(qda12_conf)
```

```{r}
qda24.fit <- qda(crisis ~ ., data = compressed_ret_24)
qda24.fit

qda24_conf <- t(table(predict(qda24.fit,type="class")$class, returns$crisis))
names(dimnames(qda24_conf)) <- c('TRUE', 'PREDICTED')
print('Confusion Matrix:')
print(qda24_conf)
```

```{r}
apers <- c((sum(qda3_conf)-tr(qda3_conf))/sum(qda3_conf), (sum(qda6_conf)-tr(qda6_conf))/sum(qda6_conf), (sum(qda12_conf)-tr(qda12_conf))/sum(qda12_conf), (sum(qda24_conf)-tr(qda24_conf))/sum(qda24_conf))

midpts <- barplot(apers, col="#69b3a2", main="APER metric of qda models", xlab="Number of PCA components")
axis(1, at = midpts, labels=c('3', '6', '12', '24'), cex.axis=0.9) # shrinks axis labels
grid(nx=NA, ny=NULL)

print(apers)
```

